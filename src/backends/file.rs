use anyhow::{Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use tracing::{debug, info};

use super::secret_backend::{SecretBackend, SecretData};

/// File-based backend for storing secrets in local flat files
/// 
/// Format: Each secret is stored in a file with key:value pairs, one per line
/// Example:
///   password:mysecret123
///   username:admin
/// 
/// Metadata is stored in a separate .meta file alongside the secret file
pub struct FileBackend {
    base_dir: PathBuf,
}

impl FileBackend {
    /// Create a new file backend
    pub fn new(base_dir: impl AsRef<Path>) -> Result<Self> {
        let mut base_dir = base_dir.as_ref().to_path_buf();
        
        // Expand tilde (~) to home directory
        if let Some(base_dir_str) = base_dir.to_str() {
            if base_dir_str.starts_with("~") {
                let home = std::env::var("HOME")
                    .context("HOME environment variable not set")?;
                base_dir = base_dir_str.replacen("~", &home, 1).into();
            }
        }
        
        // Create base directory if it doesn't exist
        if !base_dir.exists() {
            fs::create_dir_all(&base_dir)
                .with_context(|| format!("Failed to create base directory: {:?}", base_dir))?;
            info!("Created base directory: {:?}", base_dir);
        }
        
        Ok(Self { base_dir })
    }
    
    /// Convert a secret path to a file path
    /// Example: "myapp/database" -> base_dir/myapp/database
    fn path_to_file(&self, path: &str) -> PathBuf {
        self.base_dir.join(path)
    }
    
    /// Get metadata file path for a secret
    fn metadata_path(&self, path: &str) -> PathBuf {
        self.path_to_file(path).with_extension("meta")
    }
    
    /// Parse a key:value line from the secret file
    fn parse_line(line: &str) -> Option<(String, String)> {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            return None;
        }
        
        let parts: Vec<&str> = line.splitn(2, ':').collect();
        if parts.len() == 2 {
            Some((parts[0].trim().to_string(), parts[1].trim().to_string()))
        } else {
            None
        }
    }
    
    /// Format a key:value pair for writing
    fn format_line(key: &str, value: &str) -> String {
        format!("{}:{}\n", key, value)
    }
    
    /// Ensure parent directories exist for a path
    fn ensure_parent_dir(&self, file_path: &Path) -> Result<()> {
        if let Some(parent) = file_path.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("Failed to create parent directory: {:?}", parent))?;
        }
        Ok(())
    }
}

#[async_trait::async_trait]
impl SecretBackend for FileBackend {
    async fn read_secret(&self, path: &str) -> Result<SecretData> {
        debug!("Reading secret from file: {}", path);
        
        let file_path = self.path_to_file(path);
        
        if !file_path.exists() {
            anyhow::bail!("Secret file not found: {:?}", file_path);
        }
        
        let content = fs::read_to_string(&file_path)
            .with_context(|| format!("Failed to read secret file: {:?}", file_path))?;
        
        let mut data = HashMap::new();
        for line in content.lines() {
            if let Some((key, value)) = Self::parse_line(line) {
                data.insert(key, value);
            }
        }
        
        // Read metadata if it exists
        let metadata = self.read_metadata(path).await.ok();
        
        Ok(SecretData { data, metadata })
    }
    
    async fn write_secret(&self, path: &str, data: HashMap<String, String>) -> Result<()> {
        info!("Writing secret to file: {}", path);
        
        let file_path = self.path_to_file(path);
        self.ensure_parent_dir(&file_path)?;
        
        let mut content = String::new();
        content.push_str("# Secret file - Auto-generated by asr\n");
        content.push_str("# Format: key:value (one per line)\n\n");
        
        for (key, value) in &data {
            content.push_str(&Self::format_line(key, value));
        }
        
        fs::write(&file_path, content)
            .with_context(|| format!("Failed to write secret file: {:?}", file_path))?;
        
        debug!("Successfully wrote secret to: {:?}", file_path);
        Ok(())
    }
    
    async fn update_metadata(&self, path: &str, metadata: HashMap<String, String>) -> Result<()> {
        debug!("Updating metadata for: {}", path);
        
        let meta_path = self.metadata_path(path);
        self.ensure_parent_dir(&meta_path)?;
        
        let mut content = String::new();
        content.push_str("# Metadata file - Auto-generated by asr\n");
        content.push_str("# Format: key:value (one per line)\n\n");
        
        for (key, value) in &metadata {
            content.push_str(&Self::format_line(key, value));
        }
        
        fs::write(&meta_path, content)
            .with_context(|| format!("Failed to write metadata file: {:?}", meta_path))?;
        
        Ok(())
    }
    
    async fn read_metadata(&self, path: &str) -> Result<HashMap<String, String>> {
        let meta_path = self.metadata_path(path);
        
        if !meta_path.exists() {
            return Ok(HashMap::new());
        }
        
        let content = fs::read_to_string(&meta_path)
            .with_context(|| format!("Failed to read metadata file: {:?}", meta_path))?;
        
        let mut metadata = HashMap::new();
        for line in content.lines() {
            if let Some((key, value)) = Self::parse_line(line) {
                metadata.insert(key, value);
            }
        }
        
        Ok(metadata)
    }
    
    async fn list_secrets(&self, path: &str) -> Result<Vec<String>> {
        debug!("Listing secrets at path: {}", path);
        
        let dir_path = if path.is_empty() {
            self.base_dir.clone()
        } else {
            self.path_to_file(path)
        };
        
        if !dir_path.exists() {
            return Ok(Vec::new());
        }
        
        let mut secrets = Vec::new();
        
        // If it's a directory, list files in it
        if dir_path.is_dir() {
            let entries = fs::read_dir(&dir_path)
                .with_context(|| format!("Failed to read directory: {:?}", dir_path))?;
            
            for entry in entries {
                let entry = entry.context("Failed to read directory entry")?;
                let file_path = entry.path();
                
                // Skip metadata files and hidden files
                if file_path.extension().map(|e| e == "meta").unwrap_or(false) {
                    continue;
                }
                
                if file_path.is_file() {
                    // Get relative path from base_dir
                    if let Ok(relative) = file_path.strip_prefix(&self.base_dir) {
                        let secret_path = relative.to_string_lossy().to_string();
                        secrets.push(secret_path);
                    }
                } else if file_path.is_dir() {
                    // Recursively list secrets in subdirectories
                    let sub_path = if path.is_empty() {
                        file_path.file_name().unwrap().to_string_lossy().to_string()
                    } else {
                        format!("{}/{}", path, file_path.file_name().unwrap().to_string_lossy())
                    };
                    
                    let sub_secrets = self.list_secrets(&sub_path).await?;
                    secrets.extend(sub_secrets);
                }
            }
        } else {
            // If it's a file, return just that file
            if let Ok(relative) = dir_path.strip_prefix(&self.base_dir) {
                secrets.push(relative.to_string_lossy().to_string());
            }
        }
        
        Ok(secrets)
    }
    
    fn backend_type(&self) -> &'static str {
        "file"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    
    #[tokio::test]
    async fn test_write_and_read_secret() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let backend = FileBackend::new(temp_dir.path())?;
        
        let mut data = HashMap::new();
        data.insert("password".to_string(), "test123".to_string());
        data.insert("username".to_string(), "admin".to_string());
        
        backend.write_secret("test/secret", data.clone()).await?;
        
        let secret = backend.read_secret("test/secret").await?;
        assert_eq!(secret.data, data);
        
        Ok(())
    }
    
    #[tokio::test]
    async fn test_metadata() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let backend = FileBackend::new(temp_dir.path())?;
        
        let mut metadata = HashMap::new();
        metadata.insert("rotation_enabled".to_string(), "true".to_string());
        metadata.insert("last_rotated".to_string(), "2024-01-01".to_string());
        
        backend.update_metadata("test/secret", metadata.clone()).await?;
        
        let read_meta = backend.read_metadata("test/secret").await?;
        assert_eq!(read_meta, metadata);
        
        Ok(())
    }
    
    #[tokio::test]
    async fn test_list_secrets() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let backend = FileBackend::new(temp_dir.path())?;
        
        let mut data1 = HashMap::new();
        data1.insert("password".to_string(), "pass1".to_string());
        backend.write_secret("app/db", data1).await?;
        
        let mut data2 = HashMap::new();
        data2.insert("token".to_string(), "token1".to_string());
        backend.write_secret("app/api", data2).await?;
        
        let secrets = backend.list_secrets("").await?;
        assert!(secrets.contains(&"app/db".to_string()));
        assert!(secrets.contains(&"app/api".to_string()));
        
        Ok(())
    }
    
    #[test]
    fn test_parse_line() {
        assert_eq!(
            FileBackend::parse_line("password:test123"),
            Some(("password".to_string(), "test123".to_string()))
        );
        assert_eq!(
            FileBackend::parse_line("  key  :  value  "),
            Some(("key".to_string(), "value".to_string()))
        );
        assert_eq!(FileBackend::parse_line("# comment"), None);
        assert_eq!(FileBackend::parse_line(""), None);
    }
}

